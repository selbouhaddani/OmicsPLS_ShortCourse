---
title: "Integrating multi-omics underlying Down syndrome with OmicsPLS"
subtitle: "Exercises"
author: "Said el Bouhaddani and Jeanine Houwing-Duistermaat"
date: '`r Sys.Date()`'
output:
  rmdformats::material:
    highlight: tango
    fig_width: 9
    fig_height: 7
    self_contained: yes
    keep_md: yes
    code_folding: show
---


```{css, echo=FALSE}
.Routp {
  background-color: "#D1F2EB";
  border: 2px solid grey;
  font-weight: bold;
}

.bluebox {
  padding: 1em 1em 1em 3.5em;
  background: white;
  border-left: 10px solid green;
}

.blueboxx {
  padding: 0.5em;
  background: white;
  border-left: 10px solid blue;
  display: none;
}

.question {
  background-image: url("https://github.com/selbouhaddani/Contents/raw/main/QuestionTiny.png");
  background-repeat: no-repeat;
  background-size: 3em 3em;
  background-position: left center;
}
```


```{r global_options, include = FALSE, eval=TRUE}
library(knitr)
library(rmdformats)
opts_chunk$set(fig.path='Figs/', eval=FALSE, results = "hold", fig.align = 'center', 
               class.source="Routp", echo=TRUE, warning=TRUE, message=TRUE, 
               dev='png', dpi=200, cache = FALSE)
```


<script type="text/javascript">
    function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
          e.style.display = 'block';
    }
</script>


# Introduction and description of the data

These are exercises for the OmicsPLS short course. There are several questions throughout the text, and the corresponding R code to answer the question is given after the question. The answer key contains all output of each code block as well as brief answers to the questions. Note that some questions don't have a unique answer, but the idea should be clear. 

## Integrative analysis

In this part, we consider a data integration approach to link the information in methylation and glycomics data. This 'joint information' is then related to Down syndrome. In the exercises, we work with a subset of methylation only on chromosome 21. 

A flexible data integration approach for two heterogeneous datasets is O2PLS and is available in the OmicsPLS package. We will use OmicsPLS to select the most important genes corresponding with the methylation sites, this mapping can be found in the `CpG_groups` object where each CpG (methylation) site has one or more associated genes. The number of methylation sites is found by running `length(CpG_groups)`, and the number of genes is found with `length(unique(CpG_groups))`.


## Load packages and datasets

We need several packages for data handling, fitting and visualizing the results. Run this code to see which are not yet installed. All packages can be installed with `install.packages`, except disgenet2r, which has a separate install command shown below. 

```{r, eval=F}
req_pack <- c("MASS", "parallel", "tidyverse", "magrittr", 
              "plotly", "OmicsPLS", "httr", "disgenet2r")
req_pack[which(!(req_pack %in% installed.packages()[,1]))]
```


```{r Load packages, message=FALSE}
library(MASS)      # statistical tools, such as lda
library(parallel)  # parallel computing
library(tidyverse) # dataset & viz tools
library(magrittr)  # pipe %>% operators
library(plotly)    # interactive plots

library(OmicsPLS)  # data integration toolkit

## Also needed but not loaded
# install.packages("httr")
# devtools::install_bitbucket("ibi_group/disgenet2r")
```

The datasets are found in the `DownSyndrome.RData` file. We work with a subset of the methylation data measured only on chromosome 21.  A simple `load` statement should load them in your workspace. The `str` function can be used to get a first impression of the data objects. 

```{r Load and inspect datasets}
load("DownSyndrome.RData")  
## str gives an overview of all kinds of objects
cat("Methylation data:\n")
str(methylation)
cat("\nGlycomics data:\n")
str(glycomics)
cat("\nCpG mapping to gene:\n")
str(CpG_groups)
```

## Descriptive analysis

Before any analysis can be performed, you should consider calculating some descriptives about the data. 

:::: {.bluebox .question data-latex=""}
**_Exercises._** Plot boxplots of (a subset of) the data columns. Also describe the demographics: case-controls, age and sex distributions. Are there any remarkable observations? 
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo0');">
**_Answers (Click here)_** 
</a>
<div id="foo0" style="display:none">
The variables appear to be symmetric, without large outliers. There are some large variance CpG variables. There are 29 DS patients, 29 mothers, and 27 siblings. You can further inspect age and sex distributions using `hist` and `table`, e.g. `table(ClinicalVars$sex, ClinicalVars$group)`. 
</div>
::::

\ 



```{r Descriptive plots}
boxplot(glycomics)
boxplot(methylation[,1:100])
print(ClinicalVars)
table(ClinicalVars$group)
```


# Cross-validation to choose number of OmicsPLS components


## Choosing the number of components 

To apply OmicsPLS, we first need to decide on the number of components to retain. A cross-validation is usually performed. In the cross-validation, a grid is specified as well as the number of folds. If desired, you can use multiple cores to speed up the calculations. On a Windows machine, this requires copying the data matrices to each parallel process, so keep an eye on memory usage. 

Note that there are other ways besides cross-validation, such as the scree plot ([click here for more info](https://selbouhaddani.eu/2020-10-11-Introduction-OmicsPLS-scree/)).

:::: {.bluebox .question data-latex=""}
Perform a cross-validation for the number of joint and specific components. What is the optimal number of components for each part? 
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo1');">
**_Answers (Click here)_** 
</a>
<div id="foo1" style="display:none">
The optimal number of components changes a bit between runs, but 2, 4 and 6 (or 4,2,6) seems fine. One can also run the commented out lines to make a scree plot, as mentioned above. 
</div>
::::

\ 

```{r Decide on number of components, cache = TRUE}
set.seed(83654)
crossval_o2m_adjR2(X = methylation, Y = glycomics, 
                   a = 1:5, ax = 0:10, ay = 0:9, nr_folds = 10, nr_cores = 1)
## -> 2 4 6

# par(mfrow=c(1,3))
# plot(svd(crossprod(methylation,glycomics),0,0)$d^2 %>% (function(e) e/sum(e)), main='Joint Scree plot')
# plot(svd(tcrossprod(methylation),0,0)$d %>% (function(e) e/sum(e)), main="Methylation Scree plot") 
# plot(svd(crossprod(glycomics),0,0)$d %>% (function(e) e/sum(e)), main="Glycomics Scree plot")
# par(mfrow=c(1,1))
# ## -> 3 5 1

r <- 4; rx <- 2; ry <- 6

```

<!---
### Choosing the number of methylation groups

After choosing the number of components, we need to specify how many methylation groups to select (a methylation group is a set of CpG sites that were grouped because the have the same target gene). Also here, a cross-validation is possible. There are many criteria to optimize in a cross-validation. We will go through some of them. 

The first one is the covariance between the joint components in the methylation and glycomics data, $\mathrm{Cov}(T,U)$ in the left out fold. This is implemented in the function `crossval_sparsity`. The advantage is that this criterion is independent of the case-control status and can be used in all kinds of study designs. On the other hand, the resulting number of groups to keep can be too small or large with respect to the number of groups that are relevant to the case-control status. 

:::: {.bluebox .question data-latex=""}
How many unique groups do we have? Use `length` and `unique` on `CpG_groups` for this.
Using the function `crossval_sparsity`, how many groups of CpG sites should we keep?
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo2');">
**_Answers (Click here)_** 
</a>
<div id="foo2" style="display:none">
There are 483 groups. Based on the CV, we should keep 200 groups in the first component, and 40 groups in the second. 
</div>
::::

\ 


```{r Decide number of groups, based on covariance, cache = TRUE}
set.seed(7545)
crossval_sparsity(methylation, glycomics, r,rx,ry, 10, 
                  groupx = CpG_groups, keepx_seq = 1:10*40, keepy_seq = 10)

```

To explicitly run a cross-validation that optimizes for predicting Down syndrome, we need to write a piece of code ourselves. We divide the subjects in each outcome class in ten folds, such that each fold consists of around three DS cases, three siblings and three mothers. We further define a grid of ten values for the number of groups to keep, from 1 to 483. 

```{r Decide number of groups, based on predicting outcome, cache = TRUE}
cv_folds <- 10 # number of folds
cv_cores <- 1 # number of cores
cv_intervals <- 10 # a grid with keepx values (groups to keep)
cv_set <- c(DS=cut(1:29, cv_folds) %>% as.numeric, # define folds in each outcome class
              SB=cut(1:27, cv_folds) %>% as.numeric, 
              MA=cut(1:29, cv_folds) %>% as.numeric)
X <- methylation
Y <- glycomics
group <- ClinicalVars$group_ds
cv_grid <- round(seq(1,length(unique(CpG_groups)),length.out=cv_intervals))

cvoutp <- mclapply(mc.cores=cv_cores,cv_grid, # compute errors across the grid, over the folds
function(jj){
  jj <- as.numeric(jj)
  cat(jj, "/", length(unique(CpG_groups)), "; ",sep="")
  outp <- sapply(1:cv_folds, function(ii){
    iii <- which(ii == cv_set)
    Xtst <- X[iii,]
    Ytst <- Y[iii,]
    Xtrn <- X[-iii,]
    Ytrn <- Y[-iii,]
    fit <- try(suppressMessages(o2m(Xtrn,Ytrn,r,rx,ry,sparse=T,keepx=jj,groupx = CpG_groups)), silent = TRUE)
    if(inherits(fit, "try-error")) fit <- suppressMessages(o2m(Xtrn,Ytrn,r,rx,ry,sparse=T,keepx=jj-1,groupx = CpG_groups))
    err1 <- mse(Y,predict(fit, X))/sqrt(ssq(Y))
    err2 <- mse(X,predict(fit, Y, "Y"))/sqrt(ssq(X))
    fit_outc <- lda(x=fit$Tt,group[-iii])
    err3 <- mse(as.numeric(group[iii])-1, 
                as.numeric(predict(
                  fit_outc,(Xtst-Xtst%*%fit$W_Y%*%t(fit$P_Y))%*%fit$W.)$class
                )-1)/sqrt(ssq(as.numeric(group[iii])-1))
    c(nr = jj, Yhat = err1, Xhat = err2, outc = err3)
  })
  outp
})
names(cvoutp) <- as.character(cv_grid)

```

An interactive plot is shown with three error types. The error when predicting $Y$ with $X$, $X$ with $Y$, and the outcome with $T$. 

:::: {.bluebox .question data-latex=""}
Based on this plot, how many groups should we keep? Based on which of the three error measures? 
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo3');">
**_Answers (Click here)_** 
</a>
<div id="foo3" style="display:none">
Based on the MSE of predicting the outcome, we keep around 100 groups. 
</div>
::::

\ 


```{r Plot CV results for number of groups}
sapply(cvoutp, function(e) rowMeans(e)) %>% t %>% 
  as.data.frame %>% mutate(across(-nr, scale)) %>% 
  gather(key = "Type", value = "Error", -nr) %>% 
  ggplot(aes(x=nr, y=Error, col=Type)) + geom_line() #-> p1
#ggplotly(p1)

```

We redo the cross-validation for a finer grid around potential choices for the sparsity level. This should allow us to choose the definitive number of genes to retain. 

```{r Redo CV number of groups around certain values, cache = TRUE}
cv_gridbest <- round(c(25, 50, 75, 100, 150, 175, 200))
cvoutp_best <- mclapply(mc.cores = cv_cores, cv_gridbest, 
function(jj){
  jj <- as.numeric(jj)
  cat(jj,";  ")
  outp <- sapply(1:cv_folds, function(ii){
    iii <- which(ii == cv_set)
    Xtst <- X[iii,]
    Ytst <- Y[iii,]
    Xtrn <- X[-iii,]
    Ytrn <- Y[-iii,]
    fit <- try(suppressMessages(o2m(Xtrn,Ytrn,r,rx,ry,sparse=T,keepx=jj,groupx = CpG_groups)), silent = TRUE)
    if(inherits(fit, "try-error")) fit <- suppressMessages(o2m(Xtrn,Ytrn,r,rx,ry,sparse=T,keepx=jj-1,groupx = CpG_groups))
    err1 <- mse(Y,predict(fit, X))/sqrt(ssq(Y))
    err2 <- mse(X,predict(fit, Y, "Y"))/sqrt(ssq(X))
    fit_outc <- lda(x=fit$Tt,group[-iii])
    err3 <- mse(as.numeric(group[iii])-1, 
                as.numeric(predict(
                  fit_outc,(Xtst-Xtst%*%fit$W_Y%*%t(fit$P_Y))%*%fit$W.)$class
                )-1)/sqrt(ssq(as.numeric(group[iii])-1))
    c(nr = jj, Yhat = err1, Xhat = err2, outc = err3)
  })
  outp
}); 
names(cvoutp_best) <- as.character(cv_gridbest)

```

We plot the error for each choice, using boxplots. In this way, the variation across cross-validation runs is shown. 

:::: {.bluebox .question data-latex=""}
What would you choose as definitive number of groups to keep? Why?
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo4');">
**_Answers (Click here)_** 
</a>
<div id="foo4" style="display:none">
Somewhere between 100 and 200 is the optimal number. Taken into account that the other two error measures decrease, 175 probably the best. 
</div>
::::

\ 


```{r Plot again CV results}
# sapply(cvoutp_best, function(e) rowMeans(e)) %>% t %>% 
#   as.data.frame %>% mutate(across(-nr, scale)) %>% 
#   gather(key = "Type", value = "Error", -nr) %>% 
#   ggplot(aes(x=nr, y=Error, col=Type)) + geom_line() -> p1
# ggplotly(p1)

lapply(cvoutp_best, function(e) t(e) %>%
         as.data.frame %>% gather(key = "Type", value = "Error",-nr)) %>%
  Reduce(f=bind_rows) %>%
  ggplot(aes(x=as.factor(nr), y=Error)) + geom_boxplot() +
  facet_grid(Type~.,scales = "free")

```

--->

# Apply OmicsPLS to methylation and glycomics

## Fit O2PLS

We fit O2PLS to the methylation and glycomics data, and calculate the variance explained by the joint and specific parts. 

```{r Fit OmicsPLS and summary}
fit <- o2m(methylation, glycomics, r, rx, ry)
summary(fit)

```

## Visualize the results: loadings

Next, we inspect the loadings. Each of the 3322 loading values in the methylation parts represents a CpG site indicated by a cg ID. For the glycomics parts, we have 10 glycan peaks/IDs.

Each label is a cg ID or glycan ID, and the axes represent the respective components. 

:::: {.bluebox .question data-latex=""}
Give an interpretation of these results. Which features have highest loadings, in which components? Which glycan and methylation features have the highest covariance according to the plot? Click "zoom" in RStudio if the labels don't fit on the screen. 
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo5');">
**_Answers (Click here)_** 
</a>
<div id="foo5" style="display:none">
For the glycan data: in component 1, P1 and P7 have a high loading value. In component 2, P4, P10 and P8 are relatively high. For the methylation data component 1: cg11866463, component 2: cg02464073. 
</div>
::::

\ 


```{r Plot the loadings}
plot(fit,loading_name = "Yj",i=1,j=2,label = "col") + theme_bw()
plot(fit,loading_name = "Xj",i=1,j=2,label = "col") + theme_bw()
```


## Visualize the results: scores

Next, we investigate if these joint components are associated with Down syndrome. We first look at the scatterplot of the scores, colored by DS. 

:::: {.bluebox .question data-latex=""}
Give an interpretation. Are the joint scores able to separate Down syndrome? 
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo6');">
**_Answers (Click here)_** 
</a>
<div id="foo6" style="display:none">
There is no perfect separation, but in the second component there seems to be a difference in means between Down syndrome and the other two groups. 
</div>
::::

\ 


```{r Plot the scores}
plot(data.frame(Tt=fit$Tt,U=fit$U), col = ClinicalVars$group, pch=20,
     main="Joint X and Y components against each other")
data.frame(Group = ClinicalVars$group, JPC = scores(fit, "Xjoint")) %>% 
  pivot_longer(-Group,
               names_to = "Comp", 
               values_to = "Scores") %>% 
  ggplot(aes(x=Comp, y=Scores, col=Group)) + 
  geom_boxplot() + xlab("Component") + ylab("X scores") +
  theme_bw()
```

We perform a logistic regression with the Down syndrome status as outcome, and the joint methylation scores as covariates. We exclude the mothers for now. 

:::: {.bluebox .question data-latex=""}
Which group category is the reference? Are there joint scores that are significantly associated with Down syndrome? Are the p-values correctly interpretable in this case? Why (not)? 
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo7');">
**_Answers (Click here)_** 
</a>
<div id="foo7" style="display:none">
DS is the reference (the first level when running `levels(glm_datmat$outc)`). The first joint component is significant. However, the components themselves are estimated, this extra uncertainty is not incorporated in the p-value. 
</div>
::::

\ 


```{r Logistic regression with JPC}
glm_datmat <- data.frame(JPC=scores(fit, "Xjoint"), 
           outc = ClinicalVars$group) 
glm(outc ~ ., data = glm_datmat%>% filter(outc != "MA"), family = "binomial") %>% summary()

summary(lm(JPC.1 ~ outc, data = glm_datmat))
```


# Interpretation of the top genes

We saw that joint methylation component one seemed to be significantly associated with Down syndrome: the mean scores differed significantly between DS and SB. Of interest is the genes corresponding with the top CpG sites, are their target genes representing some biological pathway? To this end, we use String-DB to cluster the selected genes. Although there is an R package for String-DB, we are going to use [the String-DB website](https://string-db.org/). On the website, click "multiple proteins". The input there is the list of selected genes. 

Although determining a threshold to select the number of 'top' CpG sites is not straightforward, we are going to select 200 based on earlier analysis of these data. We also need to map from cg ID to gene ID. 


```{r Interpretation based on selected genes}
top_cg <- order(loadings(fit, subset=1)^2,decreasing = TRUE)
gene_list <- CpG_groups[top_cg[1:200]]
gene_list %<>% paste0(collapse = ";") %>% 
  str_split(";") %>% unlist %>% unique 

```


## Using string-DB

Copy-paste the selected genes in the String-DB website. 

:::: {.bluebox .question data-latex=""}
Is there any remarkable clustering visible? Go to the analysis tab, is there any significant enrichment? 
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo8');">
**_Answers (Click here)_** 
</a>
<div id="foo8" style="display:none">
From the [https://string-db.org/](https://string-db.org/) website, choose homo sapiens as organism and paste the gene list. There is one clear cluster with many KRTAP genes, the other genes seem less clustered. Note that KRTAP (keratine associated proteins) are all located on chromosome 21. Enrichment analysis shows the complexity of the genetic architecture of DS, it is somewhat dominated by keratin related terms. The PubMed enrichment shows multiple terms investigating Down syndrome. 
</div>
::::

\ 


```{r Paste the result in e.g. string}
# gene_list %>% cat(sep="\n")
```


## Using DisGeNet 

You can also use the DisGeNet R package to perform Disease-gene enrichment. If you cannot install the package, the output is given below. 

:::: {.bluebox .question data-latex=""}
Which disease clusters are most significant? What does this say about the top genes based on integrating methylation and glycomics data? 
::::

\ 

:::: {.blueboxx data-latex=""}
<a href="javascript:void()" onclick="toggle_visibility('foo9');">
**_Answers (Click here)_** 
</a>
<div id="foo9" style="display:none">
The top hit is Down syndrome. The top genes apparently contain more genes that are associated with Down syndrome than you would expect by chance. 
</div>
::::

\ 


```{r Run DisGeNet analysis, message=FALSE}
### Bonus, run this code to perform DisGeNet enrichment
# disgenet_api_key <- "271e054761763b144a97872b059fd573186bdd9f"
options(timeout=4e9)
httr::timeout(4e9) # if needed to give curl more time
DGN_DE <- disgenet2r::disease_enrichment(gene_list, database = "ALL")
DGN_DE@qresult[1:10,
          c("Description", "FDR", "Ratio",  "BgRatio")]
```

```
                       Description          FDR Ratio   BgRatio
236                  Down Syndrome 4.983930e-35 38/65 766/21666
2736  Complete Trisomy 21 Syndrome 2.709284e-34 36/65 669/21666
2320 DOWN SYNDROME CRITICAL REGION 9.293346e-19 13/65  57/21666
1853        Chromosome 21 monosomy 1.849628e-07  5/65  13/21666
2468      Alzheimer disease type 1 1.452115e-05  3/65   3/21666
169            Cognition Disorders 8.819130e-05 12/65 607/21666
375           Hirschsprung Disease 8.819130e-05 10/65 384/21666
548             Mental Retardation 1.006005e-04 11/65 505/21666
207             Presenile dementia 2.703029e-03 11/65 718/21666
303             Fragile X Syndrome 4.152165e-03  6/65 194/21666
```


BONUS: You can also combine the String-DB and DisGeNet analyses by making an interaction netwerk of the genes in a particular disease term. Below is the code to print the genes that are in the Down Syndrome disease term. This list can be copy-pasted into String-DB and analyzed.


```{r}
DGN_DownS <- DGN_DE@qresult %>%
    filter(Description == "Down Syndrome") %>%
    pull(shared_symbol) %>% str_split(";") %>% unlist
# cat(DGN_DownS, sep="\n")

```

